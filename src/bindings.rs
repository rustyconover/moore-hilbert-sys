/* automatically generated by rust-bindgen */

pub type BitmaskT = ::std::os::raw::c_ulonglong;
pub type HalfmaskT = ::std::os::raw::c_ulong;
extern "C" {
    /// Convert an index into a Hilbert curve to a set of coordinates.
    /// # Arguments
    /// * `nDims` - Number of coordinate axes.
    /// * `nBits` - Number of bits per axis.
    /// * `index` - The index, contains `nDims` * `nBits` bits (so `nDims` * `nBits` must be <= 8 * sizeof(BitmaskT)).
    /// # Returns
    /// * `coord` - The list of nDims coordinates, each with nBits bits.
    /// # Assumptions
    /// `nDims`*`nBits` <= (sizeof index) * (`bits_per_byte`)"
    pub fn hilbert_i2c(
        nDims: ::std::os::raw::c_uint,
        nBits: ::std::os::raw::c_uint,
        index: BitmaskT,
        coord: *mut BitmaskT,
    );
}
extern "C" {
    /// Convert coordinates of a point on a Hilbert curve to its index.
    /// # Arguments
    /// * `nDims` - Number of coordinates.
    /// * `nBits` - Number of bits/coordinate.
    /// * `coord` - Array of n `nBits`-bit coordinates.
    /// # Returns
    /// * `index` - Output index value.  nDims*nBits bits.
    /// # Assumptions
    /// `nDims` * `nBits` <= (sizeof `BitmaskT`) * (`bits_per_byte`)
    pub fn hilbert_c2i(
        nDims: ::std::os::raw::c_uint,
        nBits: ::std::os::raw::c_uint,
        coord: *const BitmaskT,
    ) -> BitmaskT;
}
extern "C" {
    /// Determine which of two points lies further along the Hilbert curve
    /// # Arguments
    /// * `ndims`  - Number of coordinates.
    /// * `nBytes` - Number of bytes of storage/coordinate (hilbert_cmp only)
    /// * `nBits`  - Number of bits/coordinate. (hilbert_cmp only)
    /// * `coord1` - Array of nDims nBytes-byte coordinates (or doubles for ieee_cmp).
    /// * `coord2` - Array of nDims nBytes-byte coordinates (or doubles for ieee_cmp).
    /// # Returns
    /// * -1, 0, or 1 according to whether coord1<coord2, coord1==coord, coord1>coord2
    /// # Assumptions
    /// `nBits` <= (sizeof `BitmaskT`) * (`bits_per_byte`)"
    pub fn hilbert_cmp(
        nDims: ::std::os::raw::c_uint,
        nBytes: ::std::os::raw::c_uint,
        nBits: ::std::os::raw::c_uint,
        coord1: *const ::std::os::raw::c_void,
        coord2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Determine which of two points lies further along the Hilbert curve
    /// # Arguments
    /// * `ndims`  - Number of coordinates.
    /// * `nBytes` - Number of bytes of storage/coordinate (hilbert_cmp only)
    /// * `nBits`  - Number of bits/coordinate. (hilbert_cmp only)
    /// * `coord1` - Array of nDims doubles
    /// * `coord2` - Array of nDims doubles
    /// # Returns
    /// * -1, 0, or 1 according to whether coord1<coord2, coord1==coord, coord1>coord2
    /// # Assumptions
    /// `nBits` <= (sizeof `BitmaskT`) * (`bits_per_byte`)"
    pub fn hilbert_ieee_cmp(
        nDims: ::std::os::raw::c_uint,
        coord1: *const f64,
        coord2: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Determine the first or last vertex of a box to lie on a Hilbert curve
    /// # Arguments
    /// * `nDims`   - Number of coordinates.
    /// * `nBytes`  - Number of bytes/coordinate.
    /// * `nBits`   - Number of bits/coordinate. (hilbert_cmp only)
    /// * `findMin` - Is it the least vertex sought?
    /// * `c1`      - Array of nDims nBytes-byte coordinates - one corner of box
    /// * `c2`      - Array of nDims nBytes-byte coordinates - opposite corner
    /// # Returns
    /// `c1` and `c2` modified to refer to selected corder
    /// value returned is log2 of size of largest power-of-two-aligned box that
    /// contains the selected corner and no other corners
    /// # Assumptions
    /// `nBits` <= (sizeof `BitmaskT`) * (`bits_per_byte`)
    pub fn hilbert_box_vtx(
        nDims: ::std::os::raw::c_uint,
        nBytes: ::std::os::raw::c_uint,
        nBits: ::std::os::raw::c_uint,
        findMin: ::std::os::raw::c_int,
        c1: *mut ::std::os::raw::c_void,
        c2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Determine the first or last vertex of a box to lie on a Hilbert curve
    /// # Arguments
    /// * `nDims`   - Number of coordinates.
    /// * `findMin` - Is it the least vertex sought?
    /// * `c1`  - Array of doubles coordinates - one corner of box
    /// * `c2`  - Array of doubles coordinates - opposite corner
    /// # Returns
    /// `c1` and `c2` modified to refer to selected corder
    /// value returned is log2 of size of largest power-of-two-aligned box that
    /// contains the selected corner and no other corners
    /// # Assumptions
    /// `nBits` <= (sizeof `BitmaskT`) * (`bits_per_byte`)
    pub fn hilbert_ieee_box_vtx(
        nDims: ::std::os::raw::c_uint,
        findMin: ::std::os::raw::c_int,
        c1: *mut f64,
        c2: *mut f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Determine the first or last point of a box to lie on a Hilbert curve
    /// # Arguments
    /// * `nDims` - Number of coordinates.
    /// * `nBytes` - Number of bytes/coordinate.
    /// * `nBits` - Number of bits/coordinate.
    /// * `findMin` - Is it the least vertex sought?
    /// * `coord1` - Array of nDims nBytes-byte coordinates - one corner of box
    /// * `coord2` - Array of nDims nBytes-byte coordinates - opposite corner
    /// # Returns
    /// `c1` and `c2` are modified to refer to the least point
    /// # Assumptions
    /// `nBits` <= (sizeof `BitmaskT`) * (`bits_per_byte`)
    pub fn hilbert_box_pt(
        nDims: ::std::os::raw::c_uint,
        nBytes: ::std::os::raw::c_uint,
        nBits: ::std::os::raw::c_uint,
        findMin: ::std::os::raw::c_int,
        coord1: *mut ::std::os::raw::c_void,
        coord2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Determine the first or last point of a box to lie on a Hilbert curve
    /// # Arguments
    /// * `nDims` - Number of coordinates.
    /// * `findMin` - Is it the least vertex sought?
    /// * `coord1` - Array of nDims double coordinates - one corner of box
    /// * `coord2` - Array of nDims double coordinates - opposite corner
    /// # Returns
    /// `c1` and `c2` are modified to refer to the least point
    pub fn hilbert_ieee_box_pt(
        nDims: ::std::os::raw::c_uint,
        findMin: ::std::os::raw::c_int,
        c1: *mut f64,
        c2: *mut f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Determine the first point of a box after a given point to lie on a Hilbert curve
    /// # Arguments
    /// * `nDims`  - Number of coordinates.
    /// * `nBytes` - Number of bytes/coordinate.
    /// * `nBits`  - Number of bits/coordinate.
    /// * `findPrev`  -  Is the previous point sought?
    /// * `coord1` - Array of nDims nBytes-byte coordinates - one corner of box
    /// * `coord2` - Array of nDims nBytes-byte coordinates - opposite corner
    /// * `point`  - Array of nDims nBytes-byte coordinates - lower bound on point returned
    /// # Returns
    /// If this function returns 1: `c1` and `c2` are modified to refer to the least point after point in the box
    /// If this function returns 0: arguments unchanged, point is beyond the last point of the box
    /// # Assumptions
    /// `nBits` <= (sizeof `BitmaskT`) * (`bits_per_byte`)
    pub fn hilbert_nextinbox(
        nDims: ::std::os::raw::c_uint,
        nBytes: ::std::os::raw::c_uint,
        nBits: ::std::os::raw::c_uint,
        findPrev: ::std::os::raw::c_int,
        coord1: *mut ::std::os::raw::c_void,
        coord2: *mut ::std::os::raw::c_void,
        point: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Advance from one point to its successor on a Hilbert curve
    /// # Arguments
    /// * `nDims` - Number of coordinates.
    /// * `nBits` - Number of bits/coordinate.
    /// * `coord` - Array of nDims nBits-bit coordinates.
    /// # Returns
    /// `coord` - Next point on Hilbert curve
    /// # Assumptions
    /// `nBits` <= (sizeof `BitmaskT`) * (`bits_per_byte`)
    pub fn hilbert_incr(
        nDims: ::std::os::raw::c_uint,
        nBits: ::std::os::raw::c_uint,
        coord: *mut BitmaskT,
    );
}
